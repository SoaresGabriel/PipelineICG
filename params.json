{
  "name": "Pipeline ICG",
  "tagline": "Implementação de transformações geométricas em primitivas",
  "body": "# Introdução\r\nEste post faz parte do segundo trabalho da disciplina Introdução à Computação Gráfica, ministrada pelo Prof. Christian Azambuja Pagot da UFPB, no período 2016.1.\r\n\r\nDeve ser implementado um Pipeline Gráfico, que é um conjunto de transformações geométricas em um objeto descrito inicialmente em um sistema de coordenadas próprio (ou Espaço do Objeto) e através dessas transformações, o levaremos ao Espaço da Tela, e o desenharemos usando os algoritmos usados e desenvolvidos no [primeiro trabalho da disciplina](https://soaresgabriel.github.io/TrabalhoICG/).\r\n\r\nAlém das ferramentas já usadas no primeiro trabalho, será usada também um objLoader (já disponibilizado pelo professor) para que possamos carregar o objeto a partir de um arquivo .obj, que descreve vértices e triângulos que compõe o objeto, e também será utilizado a biblioteca Eigen, para possibilitar operações entre matrizes e vetores.\r\n\r\n### Espaço Homogêneo\r\nFaremos uso do Espaço Homogêneo nesse trabalho, veremos que ele possibilita a resolução de alguns problemas relacionado as transformações. Podemos derivar um Espaço Homogêneo, adicionando uma coordenada 'W' a pontos do espaço Euclidiano, chamamos essa de Coordenada Homogênea, dessa forma, um ponto no Espaço Euclidiano tem infinitos representantes no Espaço Homogêneo da seguinte forma:\r\n`[Euclidiano] (X, Y, Z) ⇒ (X/W, Y/W, Z/W, W) [Homogêneo]`\r\n\r\nDessa forma nesse trabalho, representaremos os vértices dos objetos, como pontos no espaço homogêneo, e usaremos inicialmente 'W=1' para simplificar, desse forma: `[Euclidiano] (X, Y, Z) ⇒ (X, Y, Z, 1) [Homogêneo]`\r\n\r\nEntão basicamente aplicaremos um conjunto de transformações, que levará o objeto entre os seguintes espaços:\r\n\r\n![Passos do Pipeline](https://soaresgabriel.github.io/PipelineICG/images/pipelinespaces.png)\r\n\r\nComo já mencionado, temos um arquivo .obj que contem as informações do objeto em seu espaço, vamos agora ao primeiro conjunto de transformações:\r\n\r\n# Espaço do Objeto ⇒ Espaço do Universo\r\nPor conveniência os objetos são descritos num sistema de coordenadas próprio, denomidado o Espaço do Objeto, dessa forma cada objeto tem seu próprio espaço. Precisamos agora levar os objetos para um espaço em comum, onde todos os objetos estarão, esse espaço é denominado o Espaço do Universo.\r\n\r\n![Levando objetos para o Espaço do Universo](https://soaresgabriel.github.io/PipelineICG/images/objecttouniverse.png)\r\n\r\nA transformação do espaço do Objeto para o Universo, se da simplesmente com transformações geométricas nos objetos, no exemplo acima, os dois objetos sofreram uma translação. Nos focaremos nas transformações mais fundamentais: Escala, Rotação e Translação, pois outras transformações podem ser obtidas como combinações dessas.\r\n\r\n## Escala\r\nA escala é simplesmente a mudança no tamanho do objeto, podemos alterar o tamanho do objeto igualmente entre todos os eixos (Escala Isotrópica), ou aplicar escalas diferentes para alguns eixos (Escala Anisotrópica), dessa forma, deformando o objeto.\r\n\r\n![Escalas](https://soaresgabriel.github.io/PipelineICG/images/Scales.png)\r\n\r\nSendo Sx, Sy e Sz, os fatores de escala para cada eixo, basicamente o que queremos é transformar o objeto da seguinte forma(Já usando a coordenada homogênea):\r\n\r\n`(X, Y, Z, 1) ⇒ (Sx*X, Sy*Y, Sz*Z, 1)`\r\n\r\nPodemos obter esse resultado multiplicando o vértice no formato Vetor Coluna, pela Matriz de Escala, da seguinte forma:\r\n\r\n![Matriz de Escala](https://soaresgabriel.github.io/PipelineICG/images/ScaleOperation.png)\r\n\r\nObserve que também conseguimos espalhar um objeto simplesmente aplicando uma escala negativa:\r\n\r\n![Espelhamento](https://soaresgabriel.github.io/PipelineICG/images/mirroring.png)\r\n\r\n## Rotação\r\nImagine um vetor w=(x,y) no plano, podemos representa-lo em coordenadas polares por `w=(r*cos(α), r*sen(α))`, onde r é a distância do ponto a origem, e α é o ângulo formado entre o vetor e o eixo x.\r\nAgora queremos rotacionar esse vetor a um certo ângulo θ, obtendo o vetor `w'=(x', y')=(r*cos(α+θ), r*sen(α+θ))`, como na imagem:\r\n\r\n![Rotacionando Vetor](https://soaresgabriel.github.io/PipelineICG/images/rotatingw.png)\r\n\r\nPelas propriedades de seno e cosseno, temos que:\r\n\r\n> x'= rcos(α+θ) = rcos(α)cos(θ) − rsin(α)sin(θ)\r\n\r\n> y'= rsen(α+θ) = rsin(α)cos(θ) + rcos(α)sin(θ)\r\n\r\nSubstituindo `x=rcos(α)` e `y=rsen(α)` nas equações anterior, temos que:\r\n\r\n> x'= xcos(θ) − ysin(θ)\r\n\r\n> y'= xsin(θ) + ycos(θ)\r\n\r\nDessa forma, poderíamos montar nossa matriz de rotação para esse caso, da seguinte forma:\r\n\r\n![Matriz de Rotação 2D](https://soaresgabriel.github.io/PipelineICG/images/RotationMatrix2D.png)\r\n\r\nJá no Espaço, que é onde nos interessa, temos mais possibilidades, temos que rotacionar ao redor de algum dos eixos, podemos usar procedimento análogo ao feito acima para encontrar a Matriz de Rotação para cada caso:\r\n\r\n![Matrizes de Rotação 3D](https://soaresgabriel.github.io/PipelineICG/images/RotationMatrixs3D.png)\r\n\r\nObserve como em cada caso, uma coordenada é mantida, confirmando em torno de qual eixo estamos rotacionando.\r\n\r\n## Shear\r\nO Shear é uma transformação que mantem o valor de uma coordenada enquanto a outra aumenta linearmente em relação aquela coordenada. Por exemplo, se aplicarmos um Shear em um quadrado no plano, ele ficará parecendo um monte de cartas inclinado:\r\n\r\n![Shear Transformation](https://soaresgabriel.github.io/PipelineICG/images/ShearTransformation.png)\r\n\r\nNeste trabalho não foi implementado o Shear, por três razões:\r\n1. É pouco usado na prática.\r\n2. No espaço temos 6 possibilidades de Shear, o que geraria uma matriz com muitos argumentos; e o mais importante:\r\n3. Não é uma Transformação Fundamental, pois pode ser representada como uma combinação de escalas e rotações, como pode ser visto abaixo:\r\n\r\n![Shear com Escala e Rotação](https://soaresgabriel.github.io/PipelineICG/images/ShearNotFundamental.png)\r\n\r\n## Translação\r\nA translação nada mais é do que o deslocamento do objeto. Esse deslocamento pode ser feito simplesmente somando uma certa constante a coordenada dos vertices do objeto: (X,Y,Z) ⇒ (X+Dx,Y+Dy,Z+Dz).\r\n\r\n![Translação](https://soaresgabriel.github.io/PipelineICG/images/Translation.png)\r\n\r\nNo Espaço não conseguiríamos representar essa transformação com uma matriz 3x3, pois o deslocamento é uma constante, e qualquer elemento da matriz estaria multiplicando uma de suas coordenadas. \r\nAi é que entra a coordenada homogênea, ao botarmos ela como 1 (na verdade pode ser qualquer valor, pois seria 'compensando' quando fizermos a divisão por w), e multiplicarmos o deslocamento por ela, estaremos apenas adicionando o próprio deslocamento que queríamos, ficando com a matriz dessa forma:\r\n\r\n![Matriz de Translação](https://soaresgabriel.github.io/PipelineICG/images/TranslationMatrix.png)\r\n\r\n## Matriz Model\r\nImagine que queremos aplicar uma escala **S** e depois uma rotação **R** em um vértice v1, originando o vértice v2.\r\nPrimeiro aplicamos a escala `vt = S*v1` e depois a rotação `v2 = R*vt`, como multiplicação de matrizes é associativa, poderíamos fazer o seguinte:\r\n> v2 = R*vt = R*(S*v1) = (R*S)*v1\r\n\r\nDessa forma poderíamos gerar uma matriz só `M= R*S` que seria multiplicado por todos os vértices do mesmo objeto. A essa matriz damos o nome de _Matriz Model_ ou Matriz de Modelagem, e é formada pela multiplicação na ordem inversa de todas as matrizes de transformação a que um objeto vai ser sujeito, e ela é a responsável por levar um objeto do Espaço do Objeto para o Espaço do Universo.\r\n\r\nVale observar que a ordem das transformações geralmente importa, assim a ordem que multiplicamos as matrizes também importa e deve ser feita na ordem inversa a que as transformações vão ser aplicadas, como demonstrado acima. Para ilustrar, imagine duas matrizes de modelagem: `M1= T*R` onde é aplicada primeiro uma rotação e depois uma translação e `M2= R*T` onde as mesmas transformações são aplicadas na ordem inversa, poderíamos ter os seguintes resultados:\r\n\r\n![Ordem de Transformação](https://soaresgabriel.github.io/PipelineICG/images/TransformationOrder.png)\r\n\r\n## Implementação\r\nDessa forma foi implementada a matriz de Modelagem, o seu conteúdo inicial é a matriz identidade (sem transformações), e ao chamarmos uma função de alguma transformação, a matriz de modelagem é multiplicada pela esquerda pela matriz da transformação, gerando a nova matriz de modelagem que aplicará as transformações na ordem em que forem chamadas.\r\nO estado da matriz de modelagem é guardado entre os frames, de forma que se quisermos \"zera-la\" temos que chamar uma função especifica que carrega a matriz identidade novamente nela.\r\n\r\n# Espaço do Universo ⇒ Espaço da Câmera\r\nPara levar do espaço do universo para a câmera, mudaremos apenas a base do sistema de coordenadas. Primeiro definimos a câmera com alguns parâmetros, depois calculamos uma nova base de forma que a câmera fique na origem e olhando para a parte negativa do eixo z.\r\n\r\n![Mudando base do universo para câmera](https://soaresgabriel.github.io/PipelineICG/images/UniverseToCamera.png)\r\n\r\nNeste trabalho, definiremos a câmera usando um ponto que será a posição ('p') da câmera, um ponto que indica para onde a câmera está olhando (lookAt 'l') e um vetor que indica a parte de cima da cena (vetor 'u'), para que a câmera não fique de cabeça para baixo por exemplo. Com a posição da câmera e o lookAt, podemos calcular o vetor da direção ao qual a câmera está olhando: d= l-p.\r\n\r\nComo queremos que a câmera olhe para o z negativo, o z da câmera (Zc) pode ser o vetor de sentido contrário ao vetor direção. Queremos ainda que a base será ortonormal (veremos depois uma vantagem), então normalizaremos (dividimos as coordenadas pelo modulo do próprio vetor, para que se origine um vetor de mesmo sentido, mas de modulo 1) todos os vetores da base.\r\n\r\nO vetor up, está no plano ZY da câmera, portanto um vetor que será perpendicular ao plano ZU (U=up), será perpendicular a z e a y, portanto podemos encontrar o Xc da câmera fazendo o produto vetorial 'Zc x U' (nesta ordem para um sistema de mão direita), e normalizamos.\r\n\r\nAgora o eixo Yc pode ser obtido da mesma forma fazendo o produto vetorial 'Zc x Xc' e normalizamos.\r\nDessa forma ficamos com o seguinte: \r\n\r\n![Base da Câmera](https://soaresgabriel.github.io/PipelineICG/images/CameraBase.png)\r\n\r\nDessa forma, podemos montar uma matriz B cujas colunas são os vetores da base da câmera, que seria a matriz que transformaria da câmera para o universo. Como queremos a transformação inversa, temos que calcular a matriz inversa. Mas como a matriz B é ortonormal, por ser formada por vetores ortonormais, então podemos calcular a inversa simplesmente transpondo B, e essa matriz transforma do espaço do universo para a câmera.\r\n\r\nMas essa matriz que montamos, leva apenas em consideração a rotação dos sistemas de coordenadas, nos casos que as origens são diferentes, precisamos ainda fazer uma translação. Essa translação é simples, basta transladar os objetos referente a posição da câmera, que será a nova origem, dai podemos montar uma matriz T de translação.\r\n\r\n![Matrizes de Rotação e Translação da Câmera](https://soaresgabriel.github.io/PipelineICG/images/ViewMatrixs.png)\r\n\r\n## Matriz View\r\nAplicando a mesma lógica que fizemos com a matriz Model, definiremos a matriz View como sendo a combinação da translação e depois da rotação `VIEW=Bt*T`. Dessa forma a matriz VIEW leva os objetos do espaço do universo para o espaço da câmera.\r\nAssim foi implementada uma função \"defineCamera\" que recebe a posição da câmera, o lookAt e o up, e já calcula a matriz View.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}