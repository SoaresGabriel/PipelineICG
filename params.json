{
  "name": "Pipeline ICG",
  "tagline": "Implementação de transformações geométricas em primitivas",
  "body": "# Introdução\r\nEste post faz parte do segundo trabalho da disciplina Introdução à Computação Gráfica, ministrada pelo Prof. Christian Azambuja Pagot da UFPB, no período 2016.1.\r\n\r\nDeve ser implementado um Pipeline Gráfico, que é um conjunto de transformações geométricas em um objeto descrito inicialmente em um sistema de coordenadas próprio (ou Espaço do Objeto) e através dessas transformações, o levaremos ao Espaço da Tela, e o desenharemos usando os algoritmos usados e desenvolvidos no [primeiro trabalho da disciplina](https://soaresgabriel.github.io/TrabalhoICG/).\r\n\r\nAlém das ferramentas já usadas no primeiro trabalho, será usada também um objLoader (já disponibilizado pelo professor) para que possamos carregar o objeto a partir de um arquivo .obj, que descreve vértices e triângulos que compõe o objeto, e também será utilizado a biblioteca Eigen, para possibilitar operações entre matrizes e vetores.\r\n\r\n### Espaço Homogêneo\r\nFaremos uso do Espaço Homogêneo nesse trabalho, veremos que ele possibilita a resolução de alguns problemas relacionado as transformações. Podemos derivar um Espaço Homogêneo, adicionando uma coordenada 'W' a pontos do espaço Euclidiano, chamamos essa de Coordenada Homogênea, dessa forma, um ponto no Espaço Euclidiano tem infinitos representantes no Espaço Homogêneo da seguinte forma:\r\n`[Euclidiano] (X, Y, Z) ⇒ (X/W, Y/W, Z/W, W) [Homogêneo]`\r\n\r\nDessa forma nesse trabalho, representaremos os vértices dos objetos, como pontos no espaço homogêneo, e usaremos inicialmente 'W=1' para simplificar, desse forma: `[Euclidiano] (X, Y, Z) ⇒ (X, Y, Z, 1) [Homogêneo]`\r\n\r\nEntão basicamente aplicaremos um conjunto de transformações, que levará o objeto entre os seguintes espaços:\r\n\r\n![Passos do Pipeline](https://soaresgabriel.github.io/PipelineICG/images/pipelinespaces.png)\r\n\r\nComo já mencionado, temos um arquivo .obj que contem as informações do objeto em seu espaço, vamos agora ao primeiro conjunto de transformações:\r\n\r\n# Espaço do Objeto ⇒ Espaço do Universo\r\nPor conveniência os objetos são descritos num sistema de coordenadas próprio, denomidado o Espaço do Objeto, dessa forma cada objeto tem seu próprio espaço. Precisamos agora levar os objetos para um espaço em comum, onde todos os objetos estarão, esse espaço é denominado o Espaço do Universo.\r\n\r\n![Levando objetos para o Espaço do Universo](https://soaresgabriel.github.io/PipelineICG/images/objecttouniverse.png)\r\n\r\nA transformação do espaço do Objeto para o Universo, se da simplesmente com transformações geométricas nos objetos, no exemplo acima, os dois objetos sofreram uma translação. Nos focaremos nas transformações mais fundamentais: Escala, Rotação e Translação, pois outras transformações podem ser obtidas como combinações dessas.\r\n\r\n## Escala\r\nA escala é simplesmente a mudança no tamanho do objeto, podemos alterar o tamanho do objeto igualmente entre todos os eixos (Escala Isotrópica), ou aplicar escalas diferentes para alguns eixos (Escala Anisotrópica), dessa forma, deformando o objeto.\r\n\r\n![Escalas](https://soaresgabriel.github.io/PipelineICG/images/Scales.png)\r\n\r\nSendo Sx, Sy e Sz, os fatores de escala para cada eixo, basicamente o que queremos é transformar o objeto da seguinte forma(Já usando a coordenada homogênea):\r\n\r\n`(X, Y, Z, 1) ⇒ (Sx*X, Sy*Y, Sz*Z, 1)`\r\n\r\nPodemos obter esse resultado multiplicando o vértice no formato Vetor Coluna, pela Matriz de Escala, da seguinte forma:\r\n\r\n![Matriz de Escala](https://soaresgabriel.github.io/PipelineICG/images/ScaleOperation.png)\r\n\r\nObserve que também conseguimos espalhar um objeto simplesmente aplicando uma escala negativa:\r\n\r\n![Espelhamento](https://soaresgabriel.github.io/PipelineICG/images/mirroring.png)\r\n\r\n## Rotação\r\nImagine um vetor w=(x,y) no plano, podemos representa-lo em coordenadas polares por `w=(r*cos(α), r*sen(α))`, onde r é a distância do ponto a origem, e α é o ângulo formado entre o vetor e o eixo x.\r\nAgora queremos rotacionar esse vetor a um certo ângulo θ, obtendo o vetor `w'=(x', y')=(r*cos(α+θ), r*sen(α+θ))`, como na imagem:\r\n\r\n![Rotacionando Vetor](https://soaresgabriel.github.io/PipelineICG/images/rotatingw.png)\r\n\r\nPelas propriedades de seno e cosseno, temos que:\r\n\r\n> x'= rcos(α+θ) = rcos(α)cos(θ) − rsin(α)sin(θ)\r\n\r\n> y'= rsen(α+θ) = rsin(α)cos(θ) + rcos(α)sin(θ)\r\n\r\nSubstituindo `x=rcos(α)` e `y=rsen(α)` nas equações anterior, temos que:\r\n\r\n> x'= xcos(θ) − ysin(θ)\r\n\r\n> y'= xsin(θ) + ycos(θ)\r\n\r\nDessa forma, poderíamos montar nossa matriz de rotação para esse caso, da seguinte forma:\r\n\r\n![Matriz de Rotação 2D](https://soaresgabriel.github.io/PipelineICG/images/RotationMatrix2D.png)\r\n\r\nJá no Espaço, que é onde nos interessa, temos mais possibilidades, temos que rotacionar ao redor de algum dos eixos, podemos usar procedimento análogo ao feito acima para encontrar a Matriz de Rotação para cada caso:\r\n\r\n![Matrizes de Rotação 3D](https://soaresgabriel.github.io/PipelineICG/images/RotationMatrixs3D.png)\r\n\r\nObserve como em cada caso, uma coordenada é mantida, confirmando em torno de qual eixo estamos rotacionando.\r\n\r\n## Shear\r\nO Shear é uma transformação que mantem o valor de uma coordenada enquanto a outra aumenta linearmente em relação aquela coordenada. Por exemplo, se aplicarmos um Shear em um quadrado no plano, ele ficará parecendo um monte de cartas inclinado:\r\n\r\n![Shear Transformation](https://soaresgabriel.github.io/PipelineICG/images/ShearTransformation.png)\r\n\r\nNeste trabalho não foi implementado o Shear, por três razões:\r\n1. É pouco usado na prática.\r\n2. No espaço temos 6 possibilidades de Shear, o que geraria uma matriz com muitos argumentos; e o mais importante:\r\n3. Não é uma Transformação Fundamental, pois pode ser representada como uma combinação de escalas e rotações, como pode ser visto abaixo:\r\n\r\n![Shear com Escala e Rotação](https://soaresgabriel.github.io/PipelineICG/images/ShearNotFundamental.png)\r\n\r\n## Translação\r\nA translação nada mais é do que o deslocamento do objeto. Esse deslocamento pode ser feito simplesmente somando uma certa constante a coordenada dos vertices do objeto: (X,Y,Z) ⇒ (X+Dx,Y+Dy,Z+Dz).\r\n\r\n![Translação](https://soaresgabriel.github.io/PipelineICG/images/Translation.png)\r\n\r\nNo Espaço não conseguiríamos representar essa transformação com uma matriz 3x3, pois o deslocamento é uma constante, e qualquer elemento da matriz estaria multiplicando uma de suas coordenadas. \r\nAi é que entra a coordenada homogênea, ao botarmos ela como 1 (na verdade pode ser qualquer valor, pois seria 'compensando' quando fizermos a divisão por w), e multiplicarmos o deslocamento por ela, estaremos apenas adicionando o próprio deslocamento que queríamos, ficando com a matriz dessa forma:\r\n\r\n![Matriz de Translação](https://soaresgabriel.github.io/PipelineICG/images/TranslationMatrix.png)\r\n\r\n## Matriz Model\r\nImagine que queremos aplicar uma escala **S** e depois uma rotação **R** em um vértice v1, originando o vértice v2.\r\nPrimeiro aplicamos a escala `vt = S*v1` e depois a rotação `v2 = R*vt`, como multiplicação de matrizes é associativa, poderíamos fazer o seguinte:\r\n> v2 = R*vt = R*(S*v1) = (R*S)*v1\r\n\r\nDessa forma poderíamos gerar uma matriz só `M= R*S` que seria multiplicado por todos os vértices do mesmo objeto. A essa matriz damos o nome de _Matriz Model_ ou Matriz de Modelagem, e é formada pela multiplicação na ordem inversa de todas as matrizes de transformação a que um objeto vai ser sujeito, e ela é a responsável por levar um objeto do Espaço do Objeto para o Espaço do Universo.\r\n\r\nVale observar que a ordem das transformações geralmente importa, assim a ordem que multiplicamos as matrizes também importa e deve ser feita na ordem inversa a que as transformações vão ser aplicadas, como demonstrado acima. Para ilustrar, imagine duas matrizes de modelagem: `M1= T*R` onde é aplicada primeiro uma rotação e depois uma translação e `M2= R*T` onde as mesmas transformações são aplicadas na ordem inversa, poderíamos ter os seguintes resultados:\r\n\r\n![Ordem de Transformação](https://soaresgabriel.github.io/PipelineICG/images/TransformationOrder.png)\r\n\r\n## Implementação\r\nDessa forma foi implementada a matriz de Modelagem, o seu conteúdo inicial é a matriz identidade (sem transformações), e ao chamarmos uma função de alguma transformação, a matriz de modelagem é multiplicada pela esquerda pela matriz da transformação, gerando a nova matriz de modelagem que aplicará as transformações na ordem em que forem chamadas.\r\nO estado da matriz de modelagem é guardado entre os frames, de forma que se quisermos \"zera-la\" temos que chamar uma função especifica que carrega a matriz identidade novamente nela.\r\n\r\n# Espaço do Universo ⇒ Espaço da Câmera\r\nPara levar do espaço do universo para a câmera, mudaremos apenas a base do sistema de coordenadas. Primeiro definimos a câmera com alguns parâmetros, depois calculamos uma nova base de forma que a câmera fique na origem e olhando para a parte negativa do eixo z.\r\n\r\n![Mudando base do universo para câmera](https://soaresgabriel.github.io/PipelineICG/images/UniverseToCamera.png)\r\n\r\nNeste trabalho, definiremos a câmera usando um ponto que será a posição ('p') da câmera, um ponto que indica para onde a câmera está olhando (lookAt 'l') e um vetor que indica a parte de cima da cena (vetor 'u'), para que a câmera não fique de cabeça para baixo por exemplo. Com a posição da câmera e o lookAt, podemos calcular o vetor da direção ao qual a câmera está olhando: d= l-p.\r\n\r\nComo queremos que a câmera olhe para o z negativo, o z da câmera (Zc) pode ser o vetor de sentido contrário ao vetor direção. Queremos ainda que a base será ortonormal (veremos depois uma vantagem), então normalizaremos (dividimos as coordenadas pelo modulo do próprio vetor, para que se origine um vetor de mesmo sentido, mas de modulo 1) todos os vetores da base.\r\n\r\nO vetor up, está no plano ZY da câmera, portanto um vetor que será perpendicular ao plano ZU (U=up), será perpendicular a z e a y, portanto podemos encontrar o Xc da câmera fazendo o produto vetorial 'Zc x U' (nesta ordem para um sistema de mão direita), e normalizamos.\r\n\r\nAgora o eixo Yc pode ser obtido da mesma forma fazendo o produto vetorial 'Zc x Xc' e normalizamos.\r\nDessa forma ficamos com o seguinte: \r\n\r\n![Base da Câmera](https://soaresgabriel.github.io/PipelineICG/images/CameraBase.png)\r\n\r\nDessa forma, podemos montar uma matriz B cujas colunas são os vetores da base da câmera, que seria a matriz que transformaria da câmera para o universo. Como queremos a transformação inversa, temos que calcular a matriz inversa. Mas como a matriz B é ortonormal, por ser formada por vetores ortonormais, então podemos calcular a inversa simplesmente transpondo B, e essa matriz transforma do espaço do universo para a câmera.\r\n\r\nMas essa matriz que montamos, leva apenas em consideração a rotação dos sistemas de coordenadas, nos casos que as origens são diferentes, precisamos ainda fazer uma translação. Essa translação é simples, basta transladar os objetos referente a posição da câmera, que será a nova origem, dai podemos montar uma matriz T de translação.\r\n\r\n![Matrizes de Rotação e Translação da Câmera](https://soaresgabriel.github.io/PipelineICG/images/ViewMatrixs.png)\r\n\r\n## Matriz View\r\nAplicando a mesma lógica que fizemos com a matriz Model, definiremos a matriz View como sendo a combinação da translação e depois da rotação `VIEW=Bt*T`. Dessa forma a matriz VIEW leva os objetos do espaço do universo para o espaço da câmera.\r\nAssim foi implementada uma função \"defineCamera\" que recebe a posição da câmera, o lookAt e o up, e já calcula a matriz View.\r\n\r\nEspaço da Câmera ⇒ Espaço de Recorte\r\nBasicamente o que faremos aqui, é aplicar uma distorção perspectiva nos objetos, de forma que objetos mais longes, pareçam menores do que objetos mais pertos. A matriz que desenvolveremos é uma mais simples, que leva em consideração o View Plane, como veremos.\r\n\r\nPrimeiro deslocamos a câmera uma distância 'd' para o eixo positivo z, o que podemos fazer através dessa matriz:\r\n\r\n![Matriz de Translação para a Câmera](https://soaresgabriel.github.io/PipelineICG/images/CameraTransMatrix.png)\r\n\r\nCriaremos um view plano no eixo y, e projetamos os vértices do objeto contra esse view plane em relação a posição da câmera, de forma que obtemos uma nova altura para o objeto:\r\n\r\n![Projeção no View Plane](https://soaresgabriel.github.io/PipelineICG/images/PerspProjection.png)\r\n\r\nDe semelhança de triângulos, vem que:\r\n\r\n![](https://soaresgabriel.github.io/PipelineICG/images/PerspectiveY.png)\r\n\r\nAplicamos procedimento semelhante na coordenada X, e para o Z, também dividiremos pelo mesmo fator, embora não fosse exatamente o que queríamos, não teremos problema, pois essa divisão não mudará a ordem dos vértices em relação ao eixo Z, e dessa forma, poderemos gerar a mesma imagem final sem problemas. Assim ficamos com: \r\n\r\n![](https://soaresgabriel.github.io/PipelineICG/images/PerspProjCoord.png)\r\n\r\nComo as três coordenadas tem um fator em comum, podemos representar esse novo ponto no espaço homogêneo, apenas mudando a coordenada homogênea para esse fator em comum, pois ao transformar este ponto para o espaço euclidiano, dividiremos as coordenadas pela coordenada homogênea.\r\n\r\n![](https://soaresgabriel.github.io/PipelineICG/images/ProjVertex.png)\r\n\r\nAssim, podemos montar uma matriz que muda a coordenada homogênea para esse fator:\r\n\r\n![](https://soaresgabriel.github.io/PipelineICG/images/PerspMatrix.png)\r\n\r\n## Matriz Projection\r\nAgora montamos nossa matriz projection, que é a matriz que leva do espaço da câmera para o espaço de recorte, e é formada pela translação, com a distorção que desenvolvemos, ficando com:\r\n\r\n![Matriz Projection](https://soaresgabriel.github.io/PipelineICG/images/ProjectionMatrix.png)\r\n\r\nDessa forma, foi implementada uma função que recebe o parâmetro 'd' e já calcula a Matriz Projection. Vale ressaltar que o parâmetro d vai definir o quanto de distorção perspectiva nossa cena terá.\r\n\r\n## Espaço de Recorte ⇒ Espaço Canônico\r\nO espaço canônico será o espaço em que toda a cena visível estaria dentro de um cubo que vai de (-1,-1,-1) a (1,1,1), mas como desenvolvemos uma matriz mais simples, não temos essa garantia, por tanto o espaço canônico no escopo desse trabalho não é bem canônico, mas será o suficiente para nós.\r\n\r\nQuando transformamos do espaço da câmera para o espaço de recorte, basicamente aplicamos uma translação nos vértices e mudamos a coordenada homogênea para um fator ao qual as coordenadas deveriam serem posteriormente divididas. Então a transformação do espaço de recorte para o espaço canônico, é apenas isso, pegamos cada vértice e dividimos por sua coordenada homogênea W, voltando a um ponto da forma (X,Y,Z,1), onde (X,Y,Z) serão os vértices novamente no espaço euclidiano.\r\n\r\n## Espaço Canônico ⇒ Espaço de Tela\r\nAgora levaremos nossa cena para o espaço de tela, onde as coordenadas corresponderão a pixeis na tela de visualização.\r\nComo falado acima, no espaço canônico ideal, nossa cena estaria em um cubo que vai de (-1,-1,-1) a (1,1,1). Nossa câmera está no eixo z olhando para lado negativo do eixo, então é como se nós projetamos nossa cena em um certo plano XY, já que nosso espaço de tela é bidimensional, dessa forma manipularemos as coordenadas XY dos vértices, para que correspondam as coordenadas no espaço de tela.\r\nO primeira coisa que observamos é que na tela, o eixo Y cresce para baixo, por isso a primeira coisa que fazemos é espelhar o eixo Y, o que pode ser feito aplicando uma escala de -1:\r\n\r\n![](https://soaresgabriel.github.io/PipelineICG/images/S1Matrix.png)\r\n\r\nNosso espaço de tela também não tem coordenadas negativas, então podemos aplicar uma translação de 1 em x e em y, para que nossa cena fique no intervalo (0,0) à (2,2) (considerando apenas XY).\r\n\r\n![](https://soaresgabriel.github.io/PipelineICG/images/TMatrix.png)\r\n\r\nSendo W a largura da tela e H a altura da tela, temos que nosso espaço de tela vai de (0,0) à (W-1, H-1), então aplicamos uma escala de (W-1)/2 em X e (H-1)/2 em Y, para que nossa cena fique nesse intervalo.\r\n\r\n![](https://soaresgabriel.github.io/PipelineICG/images/S2Matrix.png)\r\n\r\nComo nosso espaço de tela tem apenas coordenadas inteiras, depois disso, basta arredondarmos as coordenadas dos vértices, para obter uma aproximação no espaço de tela.\r\n\r\n## Matriz ViewPort\r\nAgora montamos nossa matriz ViewPort como a combinação das transformações anteriores `ViewPort= S2*T*S1`, e ela quem leva do espaço canônico para o espaço de tela. Então foi implementada uma função que recebe a largura e a altura da janela de visualização e calcula a matriz ViewPort.\r\n\r\n# Implementação\r\nAgora temos já implementadas nossas matrizes que levam por cada espaço do pipeline, foram desenvolvidas funções que calculam essas matrizes, conforme foi falado ao longo desse post.\r\n\r\nA ideia como falado anteriormente é combinar as matrizes para que posteriormente, para que possamos multiplicar nossos vértices por uma matriz só que faça diversas transformações, diminuindo assim o número total de operações.\r\n\r\nEntão quando vamos desenhar um objeto no nosso programa, após gerarmos cada matriz nos procedimentos falados nos outros tópicos, faremos o seguinte: Primeiro vamos gerar a matriz `MODELVIEWPROJECTION= PROJECTION*VIEW*MODEL` essa matriz levará nossos vértices do espaço do objeto, direto para o espaço de recorte, depois dividimos cada vértice por sua coordenada homogênea W, para levarmos os vértices do espaço de recorte para o espaço canônico, e por último multiplicamos os vértices pela matriz VIEWPORT, para levarmos do espaço canônico para o espaço de tela.\r\n\r\nConforme falado pelo Prof. Christian, e confirmado no meu teste, podemos deixar a divisão por W para o final que o resultado será idêntico, dessa forma geramos a matriz `MVPV = VIEWPORT*PROJECTION*VIEW*MODEL`, então multiplicamos nossos vértices por essa matriz e depois fazemos a divisão por W, diminuindo mais ainda o número de operações e obtendo o mesmo resultado.\r\n\r\nCom o objLoader, carregamos um triângulo por vez (3 vértices), aplicamos as transformações acima nos 3 vértices, agora para cada vértice geramos um struct Pixel (implementado no trabalho 1), onde as coordenadas são as mesmas de cada vértice após nós arredondarmos, e desses 3 structs Pixel's nós geramos um struct Triangle (trabalho anterior), e chamamos a função drawTriangle, que também foi implementada no trabalho anterior, para desenhar esse triângulo na tela. Após desenharmos todos os triângulos, já devemos ter nosso objeto desenhado na tela.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}