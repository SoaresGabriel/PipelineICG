<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Pipeline ICG by SoaresGabriel</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Pipeline ICG</h1>
      <h2 class="project-tagline">Implementação de transformações geométricas em primitivas</h2>
      <a href="https://github.com/SoaresGabriel/PipelineICG" class="btn">View on GitHub</a>
      <a href="https://github.com/SoaresGabriel/PipelineICG/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/SoaresGabriel/PipelineICG/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="introdução" class="anchor" href="#introdu%C3%A7%C3%A3o" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Introdução</h1>

<p>Este post faz parte do segundo trabalho da disciplina Introdução à Computação Gráfica, ministrada pelo Prof. Christian Azambuja Pagot da UFPB, no período 2016.1.</p>

<p>Deve ser implementado um Pipeline Gráfico, que é um conjunto de transformações geométricas em um objeto descrito inicialmente em um sistema de coordenadas próprio (ou Espaço do Objeto) e através dessas transformações, o levaremos ao Espaço da Tela, e o desenharemos usando os algoritmos usados e desenvolvidos no <a href="https://soaresgabriel.github.io/TrabalhoICG/">primeiro trabalho da disciplina</a>.</p>

<p>Além das ferramentas já usadas no primeiro trabalho, será usada também um objLoader (já disponibilizado pelo professor) para que possamos carregar o objeto a partir de um arquivo .obj, que descreve vértices e triângulos que compõe o objeto, e também será utilizado a biblioteca Eigen, para possibilitar operações entre matrizes e vetores.</p>

<h3>
<a id="espaço-homogêneo" class="anchor" href="#espa%C3%A7o-homog%C3%AAneo" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Espaço Homogêneo</h3>

<p>Faremos uso do Espaço Homogêneo nesse trabalho, veremos que ele possibilita a resolução de alguns problemas relacionado as transformações. Podemos derivar um Espaço Homogêneo, adicionando uma coordenada 'W' a pontos do espaço Euclidiano, chamamos essa de Coordenada Homogênea, dessa forma, um ponto no Espaço Euclidiano tem infinitos representantes no Espaço Homogêneo da seguinte forma:
<code>[Euclidiano] (X, Y, Z) ⇒ (X/W, Y/W, Z/W, W) [Homogêneo]</code></p>

<p>Dessa forma nesse trabalho, representaremos os vértices dos objetos, como pontos no espaço homogêneo, e usaremos inicialmente 'W=1' para simplificar, desse forma: <code>[Euclidiano] (X, Y, Z) ⇒ (X, Y, Z, 1) [Homogêneo]</code></p>

<p>Então basicamente aplicaremos um conjunto de transformações, que levará o objeto entre os seguintes espaços:</p>

<p><img src="https://soaresgabriel.github.io/PipelineICG/images/pipelinespaces.png" alt="Passos do Pipeline"></p>

<p>Como já mencionado, temos um arquivo .obj que contem as informações do objeto em seu espaço, vamos agora ao primeiro conjunto de transformações:</p>

<h1>
<a id="espaço-do-objeto--espaço-do-universo" class="anchor" href="#espa%C3%A7o-do-objeto--espa%C3%A7o-do-universo" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Espaço do Objeto ⇒ Espaço do Universo</h1>

<p>Por conveniência os objetos são descritos num sistema de coordenadas próprio, denomidado o Espaço do Objeto, dessa forma cada objeto tem seu próprio espaço. Precisamos agora levar os objetos para um espaço em comum, onde todos os objetos estarão, esse espaço é denominado o Espaço do Universo.</p>

<p><img src="https://soaresgabriel.github.io/PipelineICG/images/objecttouniverse.png" alt="Levando objetos para o Espaço do Universo"></p>

<p>A transformação do espaço do Objeto para o Universo, se da simplesmente com transformações geométricas nos objetos, no exemplo acima, os dois objetos sofreram uma translação. Nos focaremos nas transformações mais fundamentais: Escala, Rotação e Translação, pois outras transformações podem ser obtidas como combinações dessas.</p>

<h2>
<a id="escala" class="anchor" href="#escala" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Escala</h2>

<p>A escala é simplesmente a mudança no tamanho do objeto, podemos alterar o tamanho do objeto igualmente entre todos os eixos (Escala Isotrópica), ou aplicar escalas diferentes para alguns eixos (Escala Anisotrópica), dessa forma, deformando o objeto.</p>

<p><img src="https://soaresgabriel.github.io/PipelineICG/images/Scales.png" alt="Escalas"></p>

<p>Sendo Sx, Sy e Sz, os fatores de escala para cada eixo, basicamente o que queremos é transformar o objeto da seguinte forma(Já usando a coordenada homogênea):</p>

<p><code>(X, Y, Z, 1) ⇒ (Sx*X, Sy*Y, Sz*Z, 1)</code></p>

<p>Podemos obter esse resultado multiplicando o vértice no formato Vetor Coluna, pela Matriz de Escala, da seguinte forma:</p>

<p><img src="https://soaresgabriel.github.io/PipelineICG/images/ScaleOperation.png" alt="Matriz de Escala"></p>

<p>Observe que também conseguimos espalhar um objeto simplesmente aplicando uma escala negativa:</p>

<p><img src="https://soaresgabriel.github.io/PipelineICG/images/mirroring.png" alt="Espelhamento"></p>

<h2>
<a id="rotação" class="anchor" href="#rota%C3%A7%C3%A3o" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Rotação</h2>

<p>Imagine um vetor w=(x,y) no plano, podemos representa-lo em coordenadas polares por <code>w=(r*cos(α), r*sen(α))</code>, onde r é a distância do ponto a origem, e α é o ângulo formado entre o vetor e o eixo x.
Agora queremos rotacionar esse vetor a um certo ângulo θ, obtendo o vetor <code>w'=(x', y')=(r*cos(α+θ), r*sen(α+θ))</code>, como na imagem:</p>

<p><img src="https://soaresgabriel.github.io/PipelineICG/images/rotatingw.png" alt="Rotacionando Vetor"></p>

<p>Pelas propriedades de seno e cosseno, temos que:</p>

<blockquote>
<p>x'= rcos(α+θ) = rcos(α)cos(θ) − rsin(α)sin(θ)</p>

<p>y'= rsen(α+θ) = rsin(α)cos(θ) + rcos(α)sin(θ)</p>
</blockquote>

<p>Substituindo <code>x=rcos(α)</code> e <code>y=rsen(α)</code> nas equações anterior, temos que:</p>

<blockquote>
<p>x'= xcos(θ) − ysin(θ)</p>

<p>y'= xsin(θ) + ycos(θ)</p>
</blockquote>

<p>Dessa forma, poderíamos montar nossa matriz de rotação para esse caso, da seguinte forma:</p>

<p><img src="https://soaresgabriel.github.io/PipelineICG/images/RotationMatrix2D.png" alt="Matriz de Rotação 2D"></p>

<p>Já no Espaço, que é onde nos interessa, temos mais possibilidades, temos que rotacionar ao redor de algum dos eixos, podemos usar procedimento análogo ao feito acima para encontrar a Matriz de Rotação para cada caso:</p>

<p><img src="https://soaresgabriel.github.io/PipelineICG/images/RotationMatrixs3D.png" alt="Matrizes de Rotação 3D"></p>

<p>Observe como em cada caso, uma coordenada é mantida, confirmando em torno de qual eixo estamos rotacionando.</p>

<h2>
<a id="shear" class="anchor" href="#shear" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Shear</h2>

<p>O Shear é uma transformação que mantem o valor de uma coordenada enquanto a outra aumenta linearmente em relação aquela coordenada. Por exemplo, se aplicarmos um Shear em um quadrado no plano, ele ficará parecendo um monte de cartas inclinado:</p>

<p><img src="https://soaresgabriel.github.io/PipelineICG/images/ShearTransformation.png" alt="Shear Transformation"></p>

<p>Neste trabalho não foi implementado o Shear, por três razões:
1. É pouco usado na prática.
2. No espaço temos 6 possibilidades de Shear, o que geraria uma matriz com muitos argumentos; e o mais importante:
3. Não é uma Transformação Fundamental, pois pode ser representada como uma combinação de escalas e rotações, como pode ser visto abaixo:</p>

<p><img src="https://soaresgabriel.github.io/PipelineICG/images/ShearNotFundamental.png" alt="Shear com Escala e Rotação"></p>

<h2>
<a id="translação" class="anchor" href="#transla%C3%A7%C3%A3o" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Translação</h2>

<p>A translação nada mais é do que o deslocamento do objeto. Esse deslocamento pode ser feito simplesmente somando uma certa constante a coordenada dos vertices do objeto: (X,Y,Z) ⇒ (X+Dx,Y+Dy,Z+Dz).</p>

<p><img src="https://soaresgabriel.github.io/PipelineICG/images/Translation.png" alt="Translação"></p>

<p>No Espaço não conseguiríamos representar essa transformação com uma matriz 3x3, pois o deslocamento é uma constante, e qualquer elemento da matriz estaria multiplicando uma de suas coordenadas. 
Ai é que entra a coordenada homogênea, ao botarmos ela como 1 (na verdade pode ser qualquer valor, pois seria 'compensando' quando fizermos a divisão por w), e multiplicarmos o deslocamento por ela, estaremos apenas adicionando o próprio deslocamento que queríamos, ficando com a matriz dessa forma:</p>

<p><img src="https://soaresgabriel.github.io/PipelineICG/images/TranslationMatrix.png" alt="Matriz de Translação"></p>

<h2>
<a id="matriz-model" class="anchor" href="#matriz-model" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Matriz Model</h2>

<p>Imagine que queremos aplicar uma escala <strong>S</strong> e depois uma rotação <strong>R</strong> em um vértice v1, originando o vértice v2.
Primeiro aplicamos a escala <code>vt = S*v1</code> e depois a rotação <code>v2 = R*vt</code>, como multiplicação de matrizes é associativa, poderíamos fazer o seguinte:</p>

<blockquote>
<p>v2 = R<em>vt = R</em>(S<em>v1) = (R</em>S)*v1</p>
</blockquote>

<p>Dessa forma poderíamos gerar uma matriz só <code>M= R*S</code> que seria multiplicado por todos os vértices do mesmo objeto. A essa matriz damos o nome de <em>Matriz Model</em> ou Matriz de Modelagem, e é formada pela multiplicação na ordem inversa de todas as matrizes de transformação a que um objeto vai ser sujeito, e ela é a responsável por levar um objeto do Espaço do Objeto para o Espaço do Universo.</p>

<p>Vale observar que a ordem das transformações geralmente importa, assim a ordem que multiplicamos as matrizes também importa e deve ser feita na ordem inversa a que as transformações vão ser aplicadas, como demonstrado acima. Para ilustrar, imagine duas matrizes de modelagem: <code>M1= T*R</code> onde é aplicada primeiro uma rotação e depois uma translação e <code>M2= R*T</code> onde as mesmas transformações são aplicadas na ordem inversa, poderíamos ter os seguintes resultados:</p>

<p><img src="https://soaresgabriel.github.io/PipelineICG/images/TransformationOrder.png" alt="Ordem de Transformação"></p>

<h2>
<a id="implementação" class="anchor" href="#implementa%C3%A7%C3%A3o" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Implementação</h2>

<p>Dessa forma foi implementada a matriz de Modelagem, o seu conteúdo inicial é a matriz identidade (sem transformações), e ao chamarmos uma função de alguma transformação, a matriz de modelagem é multiplicada pela esquerda pela matriz da transformação, gerando a nova matriz de modelagem que aplicará as transformações na ordem em que forem chamadas.
O estado da matriz de modelagem é guardado entre os frames, de forma que se quisermos "zera-la" temos que chamar uma função especifica que carrega a matriz identidade novamente nela.</p>

<h1>
<a id="espaço-do-universo--espaço-de-tela" class="anchor" href="#espa%C3%A7o-do-universo--espa%C3%A7o-de-tela" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Espaço do Universo ⇒ Espaço de Tela</h1>

<p>Para levar do espaço do universo para a câmera, mudaremos apenas a base do sistema de coordenadas. Primeiro definimos a câmera com alguns parâmetros, depois calculamos uma nova base de forma que a câmera fique na origem e olhando para a parte negativa do eixo z.</p>

<p><img src="https://soaresgabriel.github.io/PipelineICG/images/UniverseToCamera.png" alt="Mudando base do universo para câmera"></p>

<p>Neste trabalho, definiremos a câmera usando um ponto que será a posição ('p') da câmera, um ponto que indica para onde a câmera está olhando (lookAt 'l') e um vetor que indica a parte de cima da cena (vetor 'u'), para que a câmera não fique de cabeça para baixo por exemplo. Com a posição da câmera e o lookAt, podemos calcular o vetor da direção ao qual a câmera está olhando: d= l-p.
Como queremos que a câmera olhe para o z negativo, o z da câmera (Zc) pode ser o vetor de sentido contrário ao vetor direção. Queremos ainda que a base será ortonormal (veremos depois uma vantagem), então normalizaremos (dividimos as coordenadas pelo modulo do próprio vetor, para que se origine um vetor de mesmo sentido, mas de modulo 1) todos os vetores da base.
O vetor up, está no plano ZY da câmera, portanto um vetor que será perpendicular ao plano ZU (U=up), será perpendicular a z e a y, portanto podemos encontrar o Xc da câmera fazendo o produto vetorial 'Zc x U' (nesta ordem para um sistema de mão direita), e normalizamos.
Agora o eixo Yc pode ser obtido da mesma forma fazendo o produto vetorial 'Zc x Xc' e normalizamos.
Dessa forma ficamos com o seguinte: </p>

<p><img src="https://soaresgabriel.github.io/PipelineICG/images/CameraBase.png" alt="Base da Câmera"></p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/SoaresGabriel/PipelineICG">Pipeline ICG</a> is maintained by <a href="https://github.com/SoaresGabriel">SoaresGabriel</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
